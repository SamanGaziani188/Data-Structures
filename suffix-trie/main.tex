\documentclass[addpoints]{exam}

\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage[linguistics]{forest}
\usepackage{pseudocode}

% Header and footer.
\pagestyle{headandfoot}
\runningheadrule
\runningfootrule
\runningheader{CS 201 DS II}{Homework 4}{Spring 2018}
\runningfooter{}{Page \thepage\ of \numpages}{}
\firstpageheader{}{}{}

\boxedpoints
\printanswers

\title{\textbf{\tt Habib University}\\ \textbf{\tt CS 201 Data Structures II}\\ \textbf{\tt Spring 2018}}
\author{\textbf{\tt Emad Bin Abid - Saman Gaziani}\\ {\tt $Team: hw-4-ea02893-sg02494-4$}}
\date{\textbf{\tt Homework 4}\\ \textbf{\tt Submitted: March 12\textsuperscript{th}, 2018}}

\begin{document}
\maketitle

\begin{questions}

  \question[10] % R-13.14 
  Draw the compact representation of the suffix trie for the string: ``minimize minime''.

  \begin{solution}
    \begin{forest}
    	[[\#minime][e[\$][minime\$]][m[e\$][i[ze minime\$][nim[e\$][ize\#minime\$]]]][i[me\$][nim[e\$][ize\#minime\$]][ze\#minime\$]][nim[e\$][ize\#minime\$]][ze\#minime\$]]
    \end{forest}
  \end{solution}
\newpage
  \question[10]% C-13.43
  Give an efficient algorithm for deleting a string from a standard trie and
  analyze its running time.

  \begin{solution}\\
  	\begin{pseudocode}{Delete}{T, S}
  		\textbf{comment: }$Delete a string, s, from a standard trie, T, in O(n) time, supposing that we have$ \\$already  searched for the word.$\\ \\
  		
  		${\tt The idea of this algorithm is taken from \underline{geeksforgeeks}. The pseudocode is}$\\ ${\tt however self-generated.}$\\ \\
  		
  		\PROCEDURE{delete\_s\_from\_T}\\
  		
  		\IF( $s not found$)
  		\THEN \\
  		$return False $\\
  		
  		$u = end of s$ \\ 
  		\WHILE ($u.child$ \neq 0)
  		\DO \\
  		$v = u$\\
  		$u = u.parent$ \\ 
  		$delete v$  \\
  		
  		\ENDPROCEDURE
  	\end{pseudocode}
  \end{solution}
  \newpage
  \question[10]  % C-13.45
  Describe an algorithm for constructing the compact representation of a suffix trie, given its noncompact representation, and analyze its running time.

  \begin{solution}
    \\
    To construct compact representation of a suffix trie, we will iterate through every leaf node, and check  if it has any siblings.\\
    If the node has sibling, the pointer will move towards the paretn node without any changes in the child node. But if it has no siblings, the node will combine with the parent node and will be treated as a single node now. The pointer will remain at the same node.\\
    This procedure will be replicated till all the nodes are covered by the pointer.\\
    Running time of the above algorithm is $O(n^2)$  
  \end{solution}
\newpage
  \begin{EnvUplevel}
    The following questions refer to the 2 tables below.

    \begin{tabular}{c@{\hspace{50pt}}c}
      \begin{tabular}{|l|r|r|}
        \hline
        term & df$_t$ & idf$_t$\\\hline
        car & 18165 & 1.65\\
        auto & 6723 & 2.08\\
        insurance & 19241 & 1.62\\
        best & 25235 & 1.5\\
        \hline
      \end{tabular}
             &
               \begin{tabular}{|l|r|r|r|}
                 \hline
                 & Doc 1 & Doc 2 & Doc 3\\\hline
                 car & 27 & 4 & 24\\
                 auto & 3 & 33 & 0\\
                 insurance & 0 & 33 & 29\\
                 best & 14 & 0 & 17 \\\hline
               \end{tabular}\\
      Table 1 & Table 2
    \end{tabular}
  \end{EnvUplevel}
  \question[10]
  Consider the table of term frequencies for 3 documents denoted Doc1, Doc2, Doc3 in Table 2. Compute the tf-idf weights for the terms {\tt car, auto, insurance, best}, for each document, using the idf values from Table 1.

  \begin{solution} \\
  	\begin{center}
    	\begin{tabular}{|l|r|r|r|}
   	\hline
   	& Doc 1 & Doc 2 & Doc 3\\\hline
   	car & 44.55 & 6.6 & 39.6\\
   	auto & 6.24 & 68.64 & 0 \\
   	insurance & 0 & 53.46 & 46.98 \\
   	best & 21 & 0 & 25.5 \\\hline
   		\end{tabular}\\
  \end{center}
\end{solution}
\newpage
  \question[10]
  \label{q:weights}
  Compute the Euclidean normalized document vectors for each of the documents in Table 2, where each vector has four components, one for each of the four terms.

  \begin{solution}\\
    Doc1 = (44.55, 6.24, 0, 21)\\
    $\left| Doc1 \right| = \sqrt{44.55^2+6.24^2+0^2+21^2}$\\
    = 49.65\\
    $\frac{Doc1}{\left| Doc1 \right|}$  = ($\frac{44.55}{49.65}$ , $\frac{6.24}{49.65}$, $\frac{0}{49.65}$, $\frac{21}{49.65}$)\\
    $\frac{Doc1}{\left| Doc1 \right|}$ = (0.89, 0.12, 0, 0.42)
    \newline
    
    
    Doc2 = (6.6, 68.64, 53.46, 0)\\
    $\left| Doc2 \right| = \sqrt{6.6^2+68.64^2+53.46^2+0^2}$\\
    = 87.25\\
        $\frac{Doc2}{\left| Doc2 \right|}$  = ($\frac{6.6}{87.25}$ , $\frac{68.64}{87.25}$, $\frac{53.46}{87.25}$, $\frac{0}{87.25}$)\\
    $\frac{Doc2}{\left| Doc2 \right|}$ = (0.07, 0.78, 0.52, 0) \newline
    
    Doc3 = (39.6, 0, 46.98, 25.5)\\
    $\left| Doc3 \right| = \sqrt{39.6^2+0^2+46.98^2+25.5^2}$\\
    = 68.67 \\
        $\frac{Doc3}{\left| Doc3 \right|}$  = ($\frac{39.6}{68.67}$ , $\frac{0}{68.67}$, $\frac{46.98}{68.67}$, $\frac{25.5}{68.67}$)\\
    $\frac{Doc3}{\left| Doc3 \right|}$ = (0.57, 0, 0.72, 0.37)
    \newline
    
    
  \end{solution}
\newpage
  \question
  With term weights as computed in the Question \ref{q:weights}, rank the three documents from Table 2 by computed score for the query {\tt car insurance}, for each of the following cases of term weighting in the query.
  \begin{parts}
    \part[5] The weight of a term is 1 if present in the query, 0 otherwise.

    \begin{solution}
      q = [1, 0, 1, 0]\\
      score(q,Doc1) = 0.897 \\
      score(q,Doc2) = 0.688 \\
      score(q,Doc3) = 1.302\\
      \textbf{Ranking: } Doc3, Doc1, Doc2
      
    \end{solution}
    \part[5] Euclidean normalized idf.

    \begin{solution}
      q = [0.4778, 0.6024, 0.4692, 0.4344]\\
      score(q,Doc1) = 0.6883 \\
      score(q,Doc2) = 0.7975 \\
      score(q,Doc3) = 0.7823\\
      \textbf{Ranking: } Doc2, Doc3, Doc1
      
    \end{solution}
  \end{parts}

  \qformat{{\large\bf \thequestiontitle}\hfill[\totalpoints\ points]}
  \titledquestion{Programming Questions}
  The python skeleton files for each of the folloiwng will be added shortly.
  \begin{parts}
    \part Code a class to represent a generalized suffix tree. Words are added to it one at a time and it supports the usual query functions. Test it on a sample word list, e.g. the one at \url{http://thinkpython2.com/code/words.txt}.
    \part Code a class to represent an invertex index. Documents are added to it one at a time and it supports the usual query functions. Test it on a sample corpus, e.g. \href{https://archive.ics.uci.edu/ml/datasets/Reuters+RCV1+RCV2+Multilingual\%2C+Multiview+Text+Categorization+Test+collection}{Reuters RCV1}.
  \end{parts}      

\end{questions}

\end{document}